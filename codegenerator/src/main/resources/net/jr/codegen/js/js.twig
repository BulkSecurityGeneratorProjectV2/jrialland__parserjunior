export class {{grammar.name}}Lexer {

    const Token = Object.freeze({
    {% for terminalName in terminalNames %}    {{ terminalName }} = {{ loop.index }}{{ (loop.last) ? '' : ',' }}
    {% endfor %}
    });

    pushBack(token) {
    }
}

export class {{grammar.name}}Parser {

    const ActionType = Object.freeze({
    {% for a in actionTypeEnum %} {{ a }}{{ (loop.last) ? '' : ',' }}
    {% endfor %}
    });

    let _actions = {{ actionTypes_fnct }};

    let _actionParams = {{ actionParams_fnct }};

    let _emptyActions = {{ emptyActions_fnct }};

    let _targetRule = {{ targetRuleIndex }};

    const _nextState = {{ nextStates }};

    parse(lexer) {
        const stack = [];
        stack.push({
            rule:_targetRule,
            state:0
        });
        while(true) {
            {currentRule, currentState} = stack[stack.length-1];
            var actionType = _actions(currentState);
            if(actionType == -1) {
                actionType = _emptyActions(currentState);
                if(actionType != -1) {
                    lexerStream.pushBack(token);
                } else {
                    actionType = Parser.ActionType.FAIL;
                }
            }
            switch(actionType) {
                case Parser.ActionType.ACCEPT:
                    return stack.pop();
                case Parser.ActionType.SHIFT:
                    stack.push({
                        token:token,
                        state:_actionsParams(currentState)
                    });
                    break;
                case Parser.ActionType.REDUCE:
                    stack.push({
                         node:{},
                         state : this._actionsParams(currentState)
                    });
                    lexer.pushBack(token);
                    break;
                case Parser.ActionType.FAIL:
                default:
                    throw new Error('parse error');
                    break;
            }
        }
    }

}
